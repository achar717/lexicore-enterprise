// LexiCore™ PDF Export Service
// © 2024 LexiCore. Generate PDF reports for contract reviews.

import type { D1Database } from '@cloudflare/workers-types'

export interface ExportJobConfig {
  userId: string
  matterId?: string
  contractId?: string
  exportType: 'contract_summary' | 'review_report' | 'extraction_report' | 'audit_trail' | 'dashboard_snapshot'
  filters?: any
}

export class PDFExportService {
  constructor(private db: D1Database) {}

  /**
   * Create a new export job
   */
  async createExportJob(config: ExportJobConfig): Promise<string> {
    const jobId = `export-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
    
    await this.db.prepare(`
      INSERT INTO export_jobs (
        id, user_id, matter_id, export_type, contract_id,
        filters_json, status, created_at
      ) VALUES (?, ?, ?, ?, ?, ?, 'pending', datetime('now'))
    `).bind(
      jobId,
      config.userId,
      config.matterId || null,
      config.exportType,
      config.contractId || null,
      config.filters ? JSON.stringify(config.filters) : null
    ).run()

    console.log(`[PDF Export] Created job: ${jobId}`)
    
    return jobId
  }

  /**
   * Generate contract summary HTML (for PDF conversion)
   */
  async generateContractSummaryHTML(contractId: string): Promise<string> {
    // Fetch contract details
    const contract = await this.db.prepare(`
      SELECT 
        c.*,
        u.name as uploaded_by_name,
        m.name as matter_name
      FROM contracts c
      LEFT JOIN users u ON c.uploaded_by = u.id
      LEFT JOIN matters m ON c.matter_id = m.id
      WHERE c.id = ?
    `).bind(contractId).first<any>()

    if (!contract) {
      throw new Error('Contract not found')
    }

    // Fetch extractions
    const extractions = await this.db.prepare(`
      SELECT 
        field_category,
        field_name,
        field_value,
        verbatim_clause,
        section_reference,
        confidence_score,
        is_ambiguous,
        review_status
      FROM contract_extractions
      WHERE contract_id = ?
      ORDER BY field_category, field_name
    `).bind(contractId).all()

    const extractionsByCategory: Record<string, any[]> = {}
    for (const ext of (extractions.results || [])) {
      const category = ext.field_category as string
      if (!extractionsByCategory[category]) {
        extractionsByCategory[category] = []
      }
      extractionsByCategory[category].push(ext)
    }

    // Generate HTML
    const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Contract Summary - ${contract.contract_title}</title>
  <style>
    @page { size: A4; margin: 2cm; }
    body { font-family: 'Arial', sans-serif; font-size: 10pt; line-height: 1.4; color: #333; }
    .header { border-bottom: 2px solid #2563eb; padding-bottom: 10px; margin-bottom: 20px; }
    .header h1 { margin: 0; color: #1e40af; font-size: 20pt; }
    .header .subtitle { color: #64748b; font-size: 9pt; margin-top: 5px; }
    .metadata { background: #f8fafc; padding: 10px; border-radius: 4px; margin-bottom: 20px; }
    .metadata-row { display: flex; margin-bottom: 5px; }
    .metadata-label { font-weight: 600; width: 150px; color: #475569; }
    .metadata-value { color: #1e293b; }
    .category { margin-bottom: 20px; page-break-inside: avoid; }
    .category-header { background: #dbeafe; padding: 8px; border-radius: 4px; font-weight: 600; color: #1e40af; margin-bottom: 10px; }
    .extraction { margin-bottom: 15px; padding: 10px; border: 1px solid #e2e8f0; border-radius: 4px; }
    .extraction-header { font-weight: 600; color: #334155; margin-bottom: 5px; display: flex; justify-content: space-between; }
    .extraction-value { color: #1e293b; margin-bottom: 5px; }
    .verbatim { background: #f1f5f9; padding: 8px; border-left: 3px solid #3b82f6; font-size: 9pt; margin-top: 5px; font-style: italic; }
    .metadata-small { font-size: 8pt; color: #64748b; margin-top: 5px; }
    .badge { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 8pt; font-weight: 500; }
    .badge-green { background: #d1fae5; color: #065f46; }
    .badge-yellow { background: #fef3c7; color: #92400e; }
    .badge-red { background: #fee2e2; color: #991b1b; }
    .footer { margin-top: 30px; padding-top: 10px; border-top: 1px solid #e2e8f0; font-size: 8pt; color: #64748b; text-align: center; }
  </style>
</head>
<body>
  <div class="header">
    <h1>Contract Summary Report</h1>
    <div class="subtitle">Generated by LexiCore™ Contract Intelligence Platform</div>
  </div>

  <div class="metadata">
    <div class="metadata-row">
      <div class="metadata-label">Contract Title:</div>
      <div class="metadata-value">${contract.contract_title}</div>
    </div>
    <div class="metadata-row">
      <div class="metadata-label">Contract Type:</div>
      <div class="metadata-value">${contract.contract_type}</div>
    </div>
    <div class="metadata-row">
      <div class="metadata-label">Matter:</div>
      <div class="metadata-value">${contract.matter_name}</div>
    </div>
    <div class="metadata-row">
      <div class="metadata-label">Primary Party:</div>
      <div class="metadata-value">${contract.primary_party || 'N/A'}</div>
    </div>
    <div class="metadata-row">
      <div class="metadata-label">Counterparty:</div>
      <div class="metadata-value">${contract.counterparty || 'N/A'}</div>
    </div>
    <div class="metadata-row">
      <div class="metadata-label">Effective Date:</div>
      <div class="metadata-value">${contract.effective_date || 'N/A'}</div>
    </div>
    <div class="metadata-row">
      <div class="metadata-label">Status:</div>
      <div class="metadata-value">${contract.processing_status}</div>
    </div>
    <div class="metadata-row">
      <div class="metadata-label">Generated:</div>
      <div class="metadata-value">${new Date().toLocaleString()}</div>
    </div>
  </div>

  ${Object.entries(extractionsByCategory).map(([category, items]) => `
    <div class="category">
      <div class="category-header">${this.formatCategoryName(category)}</div>
      ${items.map((ext: any) => `
        <div class="extraction">
          <div class="extraction-header">
            <span>${ext.field_name}</span>
            <span>
              ${ext.is_ambiguous ? '<span class="badge badge-yellow">Ambiguous</span>' : ''}
              <span class="badge badge-${this.getReviewBadgeColor(ext.review_status)}">${ext.review_status || 'pending'}</span>
            </span>
          </div>
          <div class="extraction-value">${ext.field_value || 'N/A'}</div>
          ${ext.verbatim_clause ? `<div class="verbatim">"${ext.verbatim_clause}"</div>` : ''}
          <div class="metadata-small">
            ${ext.section_reference ? `Section: ${ext.section_reference} | ` : ''}
            Confidence: ${(ext.confidence_score * 100).toFixed(0)}%
          </div>
        </div>
      `).join('')}
    </div>
  `).join('')}

  <div class="footer">
    <p><strong>⚠️ PROFESSIONAL RESPONSIBILITY NOTICE</strong></p>
    <p>This AI-generated report is an advisory tool only. All extractions require attorney review.<br>
    LexiCore provides factual extraction assistance - not legal advice.</p>
    <p>Generated: ${new Date().toISOString()}</p>
  </div>
</body>
</html>
    `

    return html
  }

  /**
   * Format category name for display
   */
  private formatCategoryName(category: string): string {
    return category
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ')
  }

  /**
   * Get badge color based on review status
   */
  private getReviewBadgeColor(status?: string): string {
    switch (status) {
      case 'approved': return 'green'
      case 'rejected': return 'red'
      case 'needs_review': return 'yellow'
      default: return 'yellow'
    }
  }

  /**
   * Get export job status
   */
  async getExportJob(jobId: string): Promise<any> {
    const job = await this.db.prepare(`
      SELECT * FROM export_jobs WHERE id = ?
    `).bind(jobId).first()

    return job
  }

  /**
   * Update export job status
   */
  async updateExportJobStatus(
    jobId: string,
    status: 'processing' | 'completed' | 'failed',
    fileUrl?: string,
    fileSize?: number,
    failureReason?: string
  ): Promise<void> {
    const updates: string[] = ['status = ?']
    const values: any[] = [status]

    if (status === 'processing') {
      updates.push('started_at = datetime(\'now\')')
    } else if (status === 'completed') {
      updates.push('completed_at = datetime(\'now\')')
      updates.push('file_url = ?')
      updates.push('file_size = ?')
      updates.push('expires_at = datetime(\'now\', \'+7 days\')')
      values.push(fileUrl, fileSize)
    } else if (status === 'failed') {
      updates.push('failed_at = datetime(\'now\')')
      updates.push('failure_reason = ?')
      values.push(failureReason)
    }

    values.push(jobId)

    await this.db.prepare(`
      UPDATE export_jobs
      SET ${updates.join(', ')}
      WHERE id = ?
    `).bind(...values).run()
  }

  /**
   * Get user's export jobs
   */
  async getUserExportJobs(userId: string, limit = 20): Promise<any[]> {
    const result = await this.db.prepare(`
      SELECT 
        ej.*,
        c.contract_title,
        m.name as matter_name
      FROM export_jobs ej
      LEFT JOIN contracts c ON ej.contract_id = c.id
      LEFT JOIN matters m ON ej.matter_id = m.id
      WHERE ej.user_id = ?
      ORDER BY ej.created_at DESC
      LIMIT ?
    `).bind(userId, limit).all()

    return result.results || []
  }

  /**
   * Clean up expired export jobs
   */
  async cleanupExpiredJobs(): Promise<number> {
    const result = await this.db.prepare(`
      UPDATE export_jobs
      SET status = 'expired'
      WHERE status = 'completed'
        AND expires_at < datetime('now')
        AND status != 'expired'
    `).run()

    return result.meta.changes || 0
  }
}
